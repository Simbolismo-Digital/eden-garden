add .tool-versions

```
elixir 1.15.4-otp-26
erlang 26.0.2
nodejs 20.5.1
```

[create app](https://hexdocs.pm/phoenix/installation.html)

```
mix local.hex
mix archive.install hex phx_new
mix phx.new eden_garden
mv eden_garden/* .
mv -n eden_garden/* eden_garden/.formatter.exs eden_garden/.gitignore .
echo "" >> README.md
cat eden_garden/README.md >> README.md
rm -rf eden_garden
```

Comentei a Repo application como não pretendo trabalhar com o banco de dados imediatamente
lib/eden_garden/application.ex:14 # EdenGarden.Repo,

Up :D
mix phx.server

[create TreeServer](https://hexdocs.pm/elixir/1.12/GenServer.html)
[vídeo que ajuda a fazer algo semelhante](https://www.youtube.com/watch?v=CJT8wPnmjTM)

```
{:ok, pid} = EdenGarden.TreeServer.start_link("laranja")
EdenGarden.TreeServer.list(pid)
EdenGarden.TreeServer.pop(pid)
```

[name registration](https://hexdocs.pm/elixir/1.12/GenServer.html#module-name-registration)
observação posterior: {:via, module, name} if the server is registered through an alternative registry - será útil com o [Horde.Registry](https://hexdocs.pm/horde/Horde.Registry.html)

```
iex --sname fruits -S mix phx.server
iex --sname basket
Node.connect(:"fruits@davi-dragon")
Process.exit(:global.whereis_name("Elixir.EdenGarden.TreeServer.Macieira"), :shutdown)
Process.exit(:global.whereis_name("Elixir.EdenGarden.TreeServer.Laranjeira"), :shutdown)
Process.exit(:global.whereis_name("Elixir.EdenGarden.TreeServer.Bananeira"), :shutdown)
```

[create and registered BasketServer]
```
iex --sname fruits -S mix phx.server
iex --sname basket
Node.connect(:"fruits@davi-dragon")
EdenGarden.BasketServer.list(:global.whereis_name("Elixir.EdenGarden.BasketServer.Main"))
Process.exit(:global.whereis_name("Elixir.EdenGarden.BasketServer.Main"), :shutdown)
Process.exit(:global.whereis_name("Elixir.EdenGarden.BasketServer.Backup"), :shutdown)
```

[traping exit and graceful shutdown BasketServer](https://hexdocs.pm/elixir/1.12.3/Process.html#exit/2)

Agora ao realizar shutdown da Basket Main, é possível verificar os logs de transferências da main para a backup: `Encerrando a cesta`
Assim que a main retorna, o backup devolve o conteúdo.

```
iex --sname fruits -S mix phx.server
iex --sname basket
Node.connect(:"fruits@davi-dragon")
Process.exit(:global.whereis_name("Elixir.EdenGarden.BasketServer.Main"), :shutdown)
```

[cluster formation with libcluster gossip](https://github.com/bitwalker/libcluster)

```
# mix.exs
defp deps do
  [
    ...
    {:libcluster, "~> 3.3"}
  ]
end
```

```
# application.ex
defmodule EdenGarden.Application do
  use Application

  def start(_type, _args) do
    topologies = [
      chat: [
        strategy: Cluster.Strategy.Gossip
      ]
    ]

    children = [
      ...
      {Cluster.Supervisor, [topologies, [name: EdenGarden.ClusterSupervisor]]},
      EdenGardenWeb.Endpoint
    ]
    opts = [strategy: :one_for_one, name: EdenGarden.Supervisor]
    Supervisor.start_link(children, opts)
  end
end
```

```
# Node A
$ PORT=4000 iex --sname a -S mix phx.server
# Node B
$ iex --sname b -S mix
# Node C
$ iex --sname c -S mix
# Em qualquer nodo você pode rodar
$ Node.list
> [:"a@davi-dragon", :"b@davi-dragon"]
```

observação: para estratégias com kubernetes você pode checar o [tutorial](https://www.poeticoding.com/connecting-elixir-nodes-with-libcluster-locally-and-on-kubernetes/)


[setup a distributed cluster with Horde](https://hexdocs.pm/horde/readme.html)
* [Getting Started](https://hexdocs.pm/horde/getting_started.html)
* [Setting up a Cluster](https://hexdocs.pm/horde/libcluster.html)
* [Eventual consistency](https://hexdocs.pm/horde/eventual_consistency.html)

```
# mix.exs
defp deps do
  [
    ...
    {:horde, "~> 0.8.7"}
  ]
end
```

```
# application.ex
defmodule EdenGarden.Application do
  use Application

  def start(_type, _args) do
    ...
    children = [
      ...
      {Horde.Registry, [name: EdenGarden.HordeRegistry, keys: :unique]},
      {Horde.DynamicSupervisor, [name: EdenGarden.HordeSupervisor, strategy: :one_for_one]}
    ]
    opts = [strategy: :one_for_one, name: EdenGarden.Supervisor]
    link = Supervisor.start_link(children, opts)
    horde_start_links()
    link
  end
end
```

```
# application.ex
  def horde_start_links() do
    # Macieira
    Horde.DynamicSupervisor.start_child(EdenGarden.HordeSupervisor,
      %{
        id: "EdenGarden.TreeServer.Macieira",
        type: :supervisor,
        start: {EdenGarden.TreeServer, :start_link, ["maçã"]}
      })
    ...
  end
```

```
# Node A
$ PORT=4000 iex --sname a -S mix phx.server
[{pid, nil}] = Horde.Registry.lookup(EdenGarden.HordeRegistry, "EdenGarden.TreeServer.Macieira")
Process.exit(pid, :kill)

# Node B
$ iex --sname b -S mix
Horde.Registry.lookup(EdenGarden.HordeRegistry, "EdenGarden.TreeServer.Bananeira")

$ iex --sname c -S mix
```